# Callback Detection Vulnerabilities in Pivot Fingerprinting

## Executive Summary

The Pivot fingerprinting system (`/home/pivot/agent1/src/pivot/fingerprint.py`) has several edge cases where callback/function argument changes are **NOT detected**, causing stages to incorrectly skip re-execution when dependencies have actually changed.

The core mechanism (`inspect.getclosurevars()` + recursive fingerprinting) works well for **static** callback references but fails for **dynamic** callback resolution patterns that are common in Python.

---

## Critical Vulnerabilities

### 1. `functools.wraps` / `__wrapped__` Attribute (CRITICAL)

**File:** `/home/pivot/agent1/src/pivot/fingerprint.py`, function `hash_function_ast()`

**Issue:** `inspect.getsource()` follows the `__wrapped__` attribute chain and returns the source of the **original wrapped function**, not the actual wrapper implementation.

**Trigger:**
```python
def original():
    return 1

@functools.wraps(original)
def wrapper():
    return 999  # Completely different implementation!

# hash_function_ast(wrapper) == hash_function_ast(original)
# Both return the SAME hash!
```

**Impact:**
- Any decorator using `@functools.wraps` will have its decorator logic **completely invisible** to fingerprinting
- Affects `@functools.lru_cache`, `@functools.cache`, custom decorators, middleware patterns
- Multiple layers of decoration are collapsed to the innermost function
- Changing decorator parameters (e.g., `maxsize` in `lru_cache`) is not detected

**Root Cause:** In `hash_function_ast()`:
```python
source = inspect.getsource(func)  # Follows __wrapped__, returns wrong source!
tree = ast.parse(source)          # Parses the ORIGINAL function
```

**Fix Suggestion:** Check for `__wrapped__` attribute and either:
1. Use `marshal.dumps(func.__code__)` instead of AST parsing for wrapped functions
2. Hash both the wrapper (via `__code__`) AND the wrapped function, combining results
3. Use `inspect.getsourcefile()` + `inspect.getsourcelines()` with `stop` parameter to prevent unwrapping

---

### 2. `functools.partial` Objects (HIGH)

**File:** `/home/pivot/agent1/src/pivot/fingerprint.py`, function `get_stage_fingerprint()`

**Issue:** `functools.partial` objects fail the `is_user_code()` check because they're from stdlib (`functools` module).

**Trigger:**
```python
def base_function(multiplier, x):
    return x * multiplier

partial_v1 = functools.partial(base_function, 2)
partial_v2 = functools.partial(base_function, 3)  # Different argument!

def make_stage(p):
    def stage():
        return p(10)
    return stage

# Both stages have IDENTICAL fingerprints despite different partial args
fp1 = get_stage_fingerprint(make_stage(partial_v1))
fp2 = get_stage_fingerprint(make_stage(partial_v2))
assert fp1 == fp2  # BUG!
```

**Impact:**
- Partial function argument changes are not detected
- Wrapped function changes inside partial are not detected
- Common pattern in ML pipelines for configuring functions

**Root Cause:** In `get_stage_fingerprint()`:
```python
if callable(value) and is_user_code(value):  # partial fails is_user_code!
    _process_callable_dependency(...)
```

**Fix Suggestion:** Add special handling for `functools.partial`:
```python
if isinstance(value, functools.partial):
    # Hash the wrapped function
    _add_callable_to_manifest(f"partial:{name}.func", value.func, manifest, visited)
    # Hash the partial arguments
    manifest[f"partial:{name}.args"] = repr(value.args)
    manifest[f"partial:{name}.keywords"] = repr(value.keywords)
```

---

### 3. Instance Attribute/State Changes (HIGH)

**File:** `/home/pivot/agent1/src/pivot/fingerprint.py`, function `_process_instance_dependency()`

**Issue:** For user-defined class instances, only the **class definition** is hashed, not the instance's mutable state.

**Trigger:**
```python
class Container:
    def __init__(self):
        self._callbacks = {}

    def __getitem__(self, key):
        return self._callbacks[key]

container = Container()
container["handler"] = callback_v1

def stage():
    return container["handler"]()

fp1 = get_stage_fingerprint(stage)
container["handler"] = callback_v2  # Different callback!
fp2 = get_stage_fingerprint(stage)
assert fp1 == fp2  # BUG! Same fingerprint despite different callback
```

**Also affects:**
- `@dataclass` instances with callback fields
- Class instances with `__getattr__` interception
- Any object storing callbacks in instance attributes

**Impact:**
- Mutable containers holding callbacks are not tracked
- Configuration objects with dynamic callback assignment fail
- Registry patterns where callbacks are registered at runtime

**Root Cause:** In `_process_instance_dependency()`:
```python
cls = type(instance)
_add_callable_to_manifest(f"class:{name}.__class__", cls, ...)  # Only hashes the CLASS
# Instance state (instance.__dict__, instance._callbacks, etc.) is ignored
```

**Fix Suggestion:** This is a design decision more than a bug. Options:
1. Document as a known limitation
2. Add opt-in instance state hashing (e.g., `__fingerprint_state__()` protocol)
3. For callable instance attributes, extract and hash them

---

### 4. Class Attribute Runtime Modification (HIGH)

**File:** `/home/pivot/agent1/src/pivot/fingerprint.py`, function `get_stage_fingerprint()`

**Issue:** Class attributes modified at runtime (after class definition) are not detected.

**Trigger:**
```python
class Config:
    callback = None  # This is what gets hashed

Config.callback = callback_v1

def stage():
    return Config.callback()

fp1 = get_stage_fingerprint(stage)
Config.callback = callback_v2  # Different callback!
fp2 = get_stage_fingerprint(stage)
assert fp1 == fp2  # BUG! Config class hash is the same
```

**Impact:**
- Configuration classes with runtime-assigned callbacks fail
- Singleton pattern configurations are not tracked
- Class-level registries are invisible

**Root Cause:** When `Config` is found in globals, it's a `type` object, so it's processed as a callable and its AST (class body at definition time) is hashed. Runtime modifications to class attributes don't change the source code.

**Fix Suggestion:**
1. For classes, additionally inspect `cls.__dict__` for callable values
2. Or document as known limitation - use module-level variables instead

---

## Medium Severity Issues

### 5. Dynamic Import Functions (MEDIUM)

**Issue:** Functions obtained via `importlib.import_module()` at runtime are not tracked.

**Trigger:**
```python
def stage():
    mod = importlib.import_module("some_module")
    return mod.process()  # Not tracked - 'mod' is computed at runtime
```

**Impact:** Stages using plugin architectures or lazy imports may not re-run when plugins change.

---

### 6. `operator.methodcaller` / `operator.attrgetter` (MEDIUM)

**Issue:** These stdlib callables fail `is_user_code()` check.

**Trigger:**
```python
caller = operator.methodcaller("process")  # Not tracked
def stage(obj):
    return caller(obj)  # If "process" method changes, not detected
```

---

### 7. Descriptor Protocol / `__get__` (LOW)

**Issue:** Methods returned by descriptors at access time are not tracked.

```python
class Descriptor:
    def __get__(self, obj, objtype):
        return lambda: "dynamic"

class MyClass:
    method = Descriptor()

# obj.method is a new lambda each time, but fingerprinting doesn't see it
```

---

## What IS Working Correctly

The fingerprinting system **correctly handles**:

1. **Module-level callback variables** - Changes are detected
2. **Callbacks in nonlocal closures** - Recursively fingerprinted
3. **Callbacks in global dicts/lists** - `_process_collection_dependency()` works
4. **Multi-layer wrapped callbacks** - Closure recursion captures inner callbacks
5. **Async functions and generators** - Treated as regular callables
6. **Enum values that are callables** - Module variable change is detected

---

## Recommendations

### Immediate (P0)

1. **Fix `functools.wraps` vulnerability** - This is the most critical because:
   - It's extremely common in Python codebases
   - It completely hides decorator logic
   - The fix is straightforward (check `__wrapped__`)

### Short-term (P1)

2. **Add `functools.partial` handling** - Common pattern, easy to implement
3. **Document instance state limitations** - Users need to know this

### Long-term (P2)

4. **Consider `__fingerprint__` protocol** - Allow objects to declare what should be hashed
5. **Add static analysis for attribute access** - Detect `Config.callback` patterns in AST

---

## Test Files Created

- `/home/pivot/agent1/experiments/callback_edge_cases/test_callback_edge_cases.py` - Initial vulnerability discovery
- `/home/pivot/agent1/experiments/callback_edge_cases/deep_dive.py` - Root cause analysis
- `/home/pivot/agent1/experiments/callback_edge_cases/wraps_investigation.py` - `functools.wraps` deep dive
- `/home/pivot/agent1/experiments/callback_edge_cases/code_object_test.py` - Code object behavior
- `/home/pivot/agent1/experiments/callback_edge_cases/additional_edge_cases.py` - Additional patterns
